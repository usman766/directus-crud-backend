import { Runtime } from '../parser/index.mjs';
import * as t from '../type/index.mjs';
export declare const Module: Runtime.Module<{
    GenericArgumentList: Runtime.IUnion<unknown[]>;
    GenericArguments: Runtime.ITuple<t.TProperties>;
    Literal: Runtime.IUnion<t.TLiteral<string> | t.TLiteral<number> | t.TLiteral<boolean>>;
    Keyword: Runtime.IUnion<t.TAny | t.TBoolean | t.TBigInt | t.TNever | t.TString | t.TNumber | t.TInteger | t.TNull | t.TSymbol | t.TUndefined | t.TUnknown | t.TVoid>;
    KeyOf: Runtime.IUnion<boolean>;
    IndexArray: Runtime.IUnion<unknown[]>;
    Extends: Runtime.IUnion<unknown[]>;
    Base: Runtime.IUnion<unknown>;
    Factor: Runtime.ITuple<t.TSchema>;
    ExprTermTail: Runtime.IUnion<[] | ["&", unknown, unknown]>;
    ExprTerm: Runtime.ITuple<t.TSchema>;
    ExprTail: Runtime.IUnion<[] | ["|", unknown, unknown]>;
    Expr: Runtime.ITuple<t.TSchema>;
    Type: Runtime.IUnion<unknown>;
    PropertyKey: Runtime.IUnion<string>;
    Readonly: Runtime.IUnion<boolean>;
    Optional: Runtime.IUnion<boolean>;
    Property: Runtime.ITuple<{
        [x: string]: t.TSchema;
    }>;
    PropertyDelimiter: Runtime.IUnion<[","] | [",", "\n"] | [";"] | [";", "\n"] | ["\n"]>;
    Properties: Runtime.IUnion<t.TProperties>;
    Object: Runtime.ITuple<t.TObject<t.TProperties>>;
    Elements: Runtime.IUnion<unknown[]>;
    Tuple: Runtime.ITuple<t.TTuple<t.TSchema[]>>;
    Parameter: Runtime.ITuple<t.TSchema>;
    Function: Runtime.ITuple<t.TFunction<t.TSchema[], t.TSchema>>;
    Parameters: Runtime.IUnion<unknown[]>;
    Constructor: Runtime.ITuple<t.TConstructor<t.TSchema[], t.TSchema>>;
    Mapped: Runtime.ITuple<t.TLiteral<"Mapped types not supported">>;
    AsyncIterator: Runtime.ITuple<t.TAsyncIterator<t.TSchema>>;
    Iterator: Runtime.ITuple<t.TIterator<t.TSchema>>;
    Argument: Runtime.ITuple<t.TNever | t.TArgument<number>>;
    Awaited: Runtime.ITuple<t.TSchema>;
    Array: Runtime.ITuple<t.TArray<t.TSchema>>;
    Record: Runtime.ITuple<t.TNever>;
    Promise: Runtime.ITuple<t.TPromise<t.TSchema>>;
    ConstructorParameters: Runtime.ITuple<t.TTuple<t.TSchema[]>>;
    FunctionParameters: Runtime.ITuple<t.TTuple<t.TSchema[]>>;
    InstanceType: Runtime.ITuple<t.TSchema>;
    ReturnType: Runtime.ITuple<t.TSchema>;
    Partial: Runtime.ITuple<t.TObject<{}>>;
    Required: Runtime.ITuple<t.TObject<{}>>;
    Pick: Runtime.ITuple<t.TObject<{}>>;
    Omit: Runtime.ITuple<t.TObject<{}>>;
    Exclude: Runtime.ITuple<t.TNever>;
    Extract: Runtime.ITuple<t.TSchema>;
    Uppercase: Runtime.ITuple<t.TSchema>;
    Lowercase: Runtime.ITuple<t.TSchema>;
    Capitalize: Runtime.ITuple<t.TSchema>;
    Uncapitalize: Runtime.ITuple<t.TSchema>;
    Date: Runtime.IConst<t.TDate>;
    Uint8Array: Runtime.IConst<t.TUint8Array>;
    GenericReference: Runtime.ITuple<t.TSchema>;
    Reference: Runtime.IIdent<t.TSchema>;
}>;
